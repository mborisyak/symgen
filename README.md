# SymGen

SymGen is an interpreter and a generator of symbolic expressions. It uses mixed stack-memory machines for evaluation
and stochastic context-free grammars for generating symbolic expressions.

![](https://raw.githubusercontent.com/mborisyak/symgen/83aa06159ab8cb5c23e51b2bfe49ac170fa73a07/imgs/normalized-grammar.png)

## Why?

For sampling large datasets of "low-complexity" regression and classification tasks,
generated by symbolic expressions of limited size.

## Evaluation

### Assembly language

SymGen uses [reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) for expressions.
Instruction set of the machine comes from a library of operators, which can be easily extended with custom ones.
```python
import symgen
machine = symgen.StackMachine(symgen.lib.core, symgen.lib.std)
```
All operators, except for the core ones, have unique name (typically 3-4 letters), like `add`, `mul`.
Besides the names, *the core operators* have a special syntax:
- `<float | integer>`, e.g., `1.0` --- the `const` operator, pushes the constant into the stack;
- `(<integer>)`, e.g., `(0)` --- the `variable` operator, pushes the expression's input variable into the stack
  (indexing starts with zero);
- `[<integer>]`, e.g., `[1]` --- the `load` operator, pushes the content of the memory cell into the stack,
  the memory remains unchanged;
- `{<integer>}`, e.g., `{3}` --- the `store` operator, stores the top value from the stack into the memory cell,
the value is removed from the stack.

Below are some examples of expressions:
```
### adds 1 and 2
1.0 2.0 add
### incriments the first input variable
(0) 1 add
1 (0) add
### x / (x + y)
(0) (0) (1) add div
### sqrt(x ** 2 + y ** 2)
(0) (0) mul (1) (1) mul add sqrt
### p(x) log p(x) where p(x) = 1 / sqrt(2 pi) exp(-x * x / 2) (the constant is precomputed)
0.3989422804014327 2 (0) (0) mul div neg exp mul {0} [0] [0] log mul
```

Assembly langauge can be evaluated via `machine.__call__(expression, inputs=None, *, out=None)`
The method expected inputs as a numpy array with the shape `(number of the input variables, *batch dimensions)`
and can write to a buffer `out` with the similar dimensions.

`machine.evaluate(expression, *inputs)` is a convenience wrapper around the `__call__` method.

```python
machine.evaluate('1.0 2.0 add') # 3.0
machine.evaluate('(0) (0) mul (1) (1) mul add sqrt', 3.0, 4.0) # 5.0
machine('(0) (0) mul (1) (1) mul add sqrt', np.array([3.0, 4.0])) # np.array([5.0])
```

*Note:* arguments for functions of two and more variables are taken starting from the top of the stack, which results 
in the argument order being reversed compared to the conventional notation.
For example, `(0) (1) div` is equivalent to `(1) / (0)`.
In general, `f(arg_1, arg_2, ..., arg_n)` is equivalent to `arg_n, ..., arg_2, arg_1 f` in reverse Polish notation.

### Expression code

Expressions are stored as lists of operations, where each operation is a tuple with the name of the operator and
the optional argument, for example: `[('const', 1.0), ('const', 1.0), ('add', )]`.
`symgen.StackMachine` accepts both: an expression as a string and as a list of operations. 

An expression in the assembly language can be parsed via `symgen.StackMachine.parse`:
```python
machine = symgen.StackMachine(symgen.lib.core, symgen.lib.std)
print(machine.parse('1.0 2.0 add'))
# prints [('const', 1.0), ('const', 2.0), ('add',)]
```

### Why stack machines?

Stack machines are nicely suited for symbolic expressions. Most of the mathematical expressions can be
effortlessly converted into reverse Polish notation and executed on a stack machine: `(x + y) * z -> x y + z *`.
Naturally, reverse Polish notation is easy and intuitive to work with when generating random expressions.

While it is also possible to convert an expression into the format of RAM / register machines, they come with an additional
hurdle of keeping track of memory / registers: one either has to compile reverse Polish notations into RAM / register machine code
or directly generate such code.

### Why mixed stack-memory machines?

Stack machines have a flaw: they can't easily reuse results of subexpressions.
For example, to compute `p(x) log p(x)` where `p(x)` is some probability density, one has to
duplicate all computations for `p(x)`. Memory operators (`store` and `memory`, `{n}` and `[n]`) allow to
introduce temporary variables into the expression: `<expression for p> {0} [0] [0] log mul`.
An alternative solution, the stack duplication operator, is cumbersome to deal with during expression generation.
Another possibility, copying subexpressions during generation, wastes computational time and needlessly complicates
the generation process.

### Expanding the instruction set

One can introduce a new set of instructions by simply providing a dictionary with the Python functions:
```
my_library = dict(
  inc=lambda x: x + 1,
  sqrt=lambda x: np.sqrt(x),
)
```

`symgen` analyses the signature of the function and treats all **non keyword-only** arguments as operator inputs.
The operator can also receive the following additional arguments (if they are declared as keyword-only):
- `argument` --- the argument of the operator, for example, when executing an operator `('const', 1.0)`
`1.0` is passed as `argument`. Multiple values can be passed as a tuple, e.g., `('linear', (2.0, 1.0))`;
- `out` --- output buffer, by analogy with the most numpy functions;
- `inputs` --- inputs variables stored as a single numpy array of shape `(dim, *batch dimensions)`;
- `memory` --- a numpy buffer that holds the current state of the memory.

Normally, only the first two arguments (`argument` and `out`) are needed for custom operators,
the latter two are used by the core operators.

*Note:* to define a keyword-only arguments one can use the [star-syntax](https://docs.python.org/3/reference/compound_stmts.html#function),
for example, `lambda positional, *, keyword_only:`

*Note:* it is preferable to use the `out` argument and directly write the results into the buffer to avoid needless
copying, for example (note `[:]` before `out`):
```
inc = lambda x, *, out: out[:] = x + 1
```
or
```
inc = lambda x, *, out: np.add(x, 1, out=out)
```

If an operator uses `out` argument its output is simply ignored.
Most numpy functions support directly writing the result into a buffer (also via an optional `out` argument).

If a operator does not push anything into the stack (e.g., memory operations), it should return `None`.

## Generating random expressions

### Grammar

SymGen uses (enhanced) context-free grammar for generating random expressions.
A grammar extends instruction set (terminal symbols) with non-terminal symbols: each non-terminal symbol
is expanded according to the probabilistic transition table until all non-terminal symbols are processed.
Transition are picked randomly and are independent of the surrounding expressions (i.e., context-free).
For example, the following grammar generates random expressions with `add` and `mul` operators:
```
expr ->
    expr expr add with probability = 0.2
    expr expr mul with probability = 0.2
    constant with probability = 0.6
constant ->
    0 with probability = 0.2
    1 with probability = 0.2
    2 with probability = 0.2
    3.1415 with probability = 0.2
    2.7182 with probability = 0.2
```

In SymGen this grammar can be defined as follows:
```python
import math, random
import symgen
from symgen.generator import GeneratorMachine, symbol, op

expr = symbol('expr')
constant = symbol('constant')

rules = {
  expr: {
    expr + expr + op('add'): 0.2,
    expr + expr + op('mul'): 0.2,
    constant: 0.6,
  },
  constant: {
    op('const', 0.0): 0.2,
    op('const', 1.0): 0.2,
    op('const', 2.0): 0.2,
    op('const', math.pi): 0.2,
    op('const', math.e): 0.2,
  }
}

rng = random.Random(12345678)
generator = GeneratorMachine(symgen.lib.core, symgen.lib.std, rules=rules)

for _ in range(10):
  random_expression = generator(rng, expr)
  print(random_expression)
```

`symbol(<symbol name>)` creates a non-terminal symbol with the corresponding name.
`rules` define transition (expansion) rules, it maps `Symbol` into a transition table.
Transition table is a dictionary mapping `Expansion`s (a sequence of symbols) into likelihoods
(likelihoods are automatically normalized to 1).

If the transition table contains only one expansion, one can use the simplified syntax:
```python
rules={
  expr: subexpr + subexpr + op('add')
}
```
Also `expr: None` is an alternative to `expr: {}`.

`op(<name>, [<argument>])` instructs the generator to create an operation.


### Runaway grammars

It is quite easy to produce a "runaway" grammar: grammar that has a significant chance of exceeding any reasonable limits.
For example, the following grammar:
```
expr -> expr expr add, p = 0.9;
expr -> constant, p = 0.1;
```
has a non-zero chance of "running away" during generation.

It is highly advisable to write a priori finite grammars. The following section introduces the extension of the free grammar
that helps us, among other things, to constrain the generation process.

## Parameterized Context-Free Grammar

While context-free grammars (CFG) are a powerful tool, a lot of simple use-cases,
like restricting the depth of the expression or steering probability, require additional functionality.

Parameterized context-free grammars (PCFG) offer a simple and intuitive, yet powerful extension of CFG.
A PCFG equips non-terminal symbols with arbitrary arguments, a *context*. In `symgen` these arguments
are represented by a dictionary that maps the names of the variables into the values.
To distinguish between a symbol and a symbol with context we call the latter *non-terminal*.

To make a new non-terminal from a symbol, one can call `Symbol.seed` method, practically, one needs a non-terminal
only when specifying the initial, "seed", non-terminal.

### Conditions

A CFG operates with transition tables `non-terminal -> possible expansions`. With the introduction of the context,
non-terminals are replaced with *conditions*, a symbol equipped with a boolean function defined on the context.
A transition is active if the condition matches the symbol of the non-terminal and
the function is true on its context.
A condition can be created by calling `Symbol.when` method and passing the boolean function.

```python
expr = symbol('expr')
rules = {
  expr.when(lambda i: i < limit): ...,
  expr.when(lambda i: i >= limit): ...,
}
```

The variable names in the boolean function must match the variable names of the context.
`symgen` reads the signature of the boolean function and automatically passes all necessary arguments.

*Note:* the function can be defined on a subset of the context variables, the other variables are
passed into the *variable keyword argument* (defined by double star, e.g., `lambda **kwargs: ...`) if the function
has one, or simply filtered out otherwise.

**Important note:** when multiple conditions are satisfied, the active transition tables are merged.
The likelihoods are normalized by the sum of likelihoods in all active tables. The simplified syntax
`condition: expansion` is assigned the likelihood of 1.

*Note:* a `Symbol` alone is equivalent to the trivial condition `expr.when(lambda: True)`.

### Invocations

In PCFG, expansions are a sequence of *invocations*, symbols with context-update functions.
A context-update function creates a new context from that of the currently expanding non-terminal.
Invocation can be defined by calling `Symbol.__call__` method:

```python
expr = symbol('expr')
rules = {
  expr.when(lambda i: i < limit): {
    expr(i=lambda i: i - 1): 1.0,
    expr(i=lambda i: i - 2): 1.0,
    expr(i=lambda i: i - 1) + exp(i=lambda i: i - 1) + op('add'): 1.0,
    expr(i=lambda i: i - 1) + exp(i=lambda i: i - 1) + op('mul'): 1.0,
  }
  expr.when(lambda i: i >= limit): op('variable', ...),
}
```
The grammar above switches between transition tables depending on the depth of the expression
(tracked via variable `i`), forcing the generator to produce a concrete operation, `op('variable', ...)`, when
the depth limit is reached. Additionally, `expr` can skip 1 or 2 depth levels without producing any additional
expressions (the first two rules).

Context-update functions are defined as dictionaries `variable name: variable-update function` via
`**kwargs` of `Symbol.__call__`. Naturally, variable-update function can use any subset of the context variables.

**Note:** by convention, variables that don't have an update function are simply copied.

**Important note:** variable-update functions are independent, in particular, they always use the original context
variables. For example, in the invocation `expr(i=lambda i: i + 1, j=lambda i: i - 1)`, the update function for `j`
uses the original value of `i` not the updated one (`i + 1`).

**Auto-updates:** `Symbol` provides a convenience method `auto` that accepts context-update functions.
The auto-update functions are simply copied into all invocations produced by the symbol unless overridden:
```python
symbol_w_auto_updates = symbol('symbol').auto(depth=lambda depth: depth + 1)
another_symbol = symbol('another')

rules = {
  ...: symbol_w_auto_updates() + symbol_w_auto_updates(depth=lambda depth + 2) + another_symbol()
}
```

**Caveat:** when a non-terminal is expanded into a non-terminal of another symbol, the context is copied,
but the auto-update functions are not. This might lead to a confusing behavior, in the example above, `another_symbol`
inherits the `depth` variable but does not update it.

**Another caveat:** `auto` returns a copy of the symbol with the auto updates, but doesn't modify the original symbol.

### Parametrized operations

Operation-generating terms (`op`) can use the context to compute operations' arguments. For example,
the following grammar generates expressions that push the first `k` elements of the Fibonacci sequence into the stack: 
```python
from symgen.generator import symbol, op, GeneratorMachine
fib = symbol('fib').auto(k=lambda k: k - 1)

rules = {
  fib.when(lambda k: k > 0): op('const', lambda i: i) + fib(i=lambda i, j: i + j, j=lambda i: i),
  fib.when(lambda k: k <= 0): None
}

generator = GeneratorMachine(symgen.lib.core, rules=rules)
rng = random.Random(123)
expr = generator(rng, fib(i=1, j=1, k=10))

print(expr)
```

### Conditional likelihoods

Likelihoods cna be made conditional by replacing the concrete values with functions that accept context variables:
```python
expr = symbol('expr').auto(depth=lambda depth + 1)

rules = {
  expr: {
    expr() + expr() + op('add'): lambda depth: 1 / (depth + 1),
    op('variable', 0): 1.0
  }
}
```
As likelihoods are converted into probabilities by normalizing their sum to 1,
the probability of the first transition in the example above decreases with the depth of the expression.

### Local context

Update functions of are evaluated independently. In some cases, this might lead to wasteful computations if
the updates share heavy computations. Local context allows to introduce temporary variables into the update functions:
- local context is not propagated into the next symbol;
- it is computed before executing the usual update functions and the local variables are available for the context update functions;
- unlike normal updates, it is computed sequentially --- an update function (or rather definition) can use variables computed before it.

Local context can be declared via `where` method. Declaring local context of a `Symbol` simply passes it
to its invocations (but not to conditions, likelihoods and operations).

```python
expr = symbol('expr').where(t1=lambda i: 2 * i + 1)
rules = {
  expr.when(lambda t1: t1 < 2 * N + 1): expr(i=lambda t1, t2: t1 + t2).where(t2=lambda t1, i: t1 - 3 * i),
  expr: op('const', lambda t1: t1 / 3.0),
}
```
In the example above, the local variable `t1` is available for computing `t2`, and both, `t1` and `t2`, are used
for computing the update of `i`.

**Priority:** local context takes priority over the ordinary context, i.e., if a variable declared in both,
the value from the local context is taken.

**Note:** if it is desirable to use variables from the local context in conditions, likelihoods or operations,
one could "promote" the local variable to the global level:
```python
expr = symbol('expr').where(temp=lambda ...: ...).auto(temp=lambda temp: temp)
```
In the example above, a "global" variable `tmp` is auto-updated to match the local variable with the same name.
As local variables take priority, other computations are unaffected by the `auto` declaration.

### Random generator

Random generator (Python's `random.Random`) is available via `rng` keyword in the same manner as context variables:
```python
rules = {
  expr: op('const', lambda rng: rng.normalvariate())
}
```

The random generator, however, is not a context variable and attempting to update it will result in an error.
Moreover, even within the same expansion, invocations receive generators with different internal states. 

### Tracing

A naive approach at generating expressions often results in pathological cases:
NaNs, infinities or simply very small or very large numbers.
One could filter badly behaved expressions post factum, however,
the chances of producing a such an expression sharply raise with the increase in complexity.

Moreover, it's quite difficult to construct a set of rules that produce complex and, at the same time, stable
expressions.

`symgen.GeneratorMachine` can evaluate (trace) results of the expression as it is being generated.
To enable tracing, one should supply `inputs` argument to the `GeneratorMachine.__call__` method.
The `inputs` array should have the same shape as in `StackMachine.__call__`.
The partial results are available via the following context-like variables:
- `inputs` holds the original array;
- `stack` --- a list with the current state of the stack;
- `memory` --- a dictionary (`int -> np.ndarray`) with the current state of memory.

Note that, unlike context variables, `stack` and `memory` change from one invocation to another:
```python
rules = {
  expr: subexpr1 + subexpr2,
  ...
}
```
`subexpr2` would receive results of evaluating `subexpr1`.
Conditions, operations and likelihoods can also access the same variables.


### Rejection sampling

`symgen` allows using rejection sampling on the subexpression level via post-check declared by `assure` methods
of symbols, invocations, conditions and operations. Checks are similar to conditions except:
- they are evaluated after the expansion is complete;
- notably, they receive up-to-date `stack` and `memory`;
- however, the context is the same as at the start of the expansion,
- consequently, if context variables depend on `stack` or `memory` they might be outdated.

When a check fails the whole expansion is attempted again until the limit of attempts is reached
(`attempts` argument of `GeneratoreMachine.__call__`).

Symbol's checks are simply passed to the invocations (but not to conditions).

Below is a minimal example that demonstrates rejection sampling.

```python
import symgen
from symgen import symbol, op

def check(stack):
  return np.std(stack[-1]) < 2.0

expr = symbol('expr').auto(depth=lambda depth: depth + 1)

rules = {
  expr.assure(check): {
    expr() + expr(force_var=False) + op('add', ): (lambda depth:  1 / (depth + 1)),
    expr() + expr(force_var=False) + op('mul', ): (lambda depth: 1 / (depth + 1)),
    op('variable', lambda rng, domain: rng.choice(domain)): (lambda force_var: 0.5 if force_var else 0.25),
  },
  expr.when(lambda force_var: not force_var): {
    op('const', lambda rng: rng.normalvariate()): 0.25,
  }
}

generator = symgen.GeneratorMachine(symgen.lib.core, symgen.lib.std, rules=rules)
machine = symgen.StackMachine(symgen.lib.core, symgen.lib.std)

rng = random.Random(123456)
np_rng = np.random.default_rng(12345678)
trace = np_rng.normal(size=(2, 128)).astype(np.float32)

expression = generator.generate(rng, expr.seed(depth=0, domain=[0, 1], force_var=True), inputs=trace, attempts=16)
evaluated = machine(expression, inputs=trace)
```


