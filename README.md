# SymGen

SymGen is a fast interpreter and generator of symbolic expressions. It uses mixed stack-memory machines for evaluation
and stochastic context-free grammars for generating symbolic expressions.

## Why?

For sampling large datasets of "low-complexity" regression and classification tasks,
generated by symbolic expressions of limited size.

## How fast?

SymGen generates C code for both evaluation and generation machines, compiles it with gcc and then imports the resulting
shared library into the Python interpreter. While there is a certain overhead associated with execution of the stack
machine, the execution speed is closer to the binary code than to pure Python alternatives.

## Evaluation

## Assembly language

SymGen uses [reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation) for expressions.
Instruction set of the machine comes from a library of operators, which can be easily extended with custom ones.
```python
import symgen
machine = symgen.StackMachine(symgen.lib.core, symgen.lib.std)
```
All operators, except for the core ones, have unique name (typically 3-4 letters), like `add`, `mul`.
Besides the names, *the core operators* have special syntax:
- `<float | integer>`, e.g., `1.0` --- the `const` operator, pushes the constant into the stack;
- `(<integer>)`, e.g., `(0)` --- the `input` operator, pushes the expression's input variable into the stack
  (indexing starts with zero);
- `[<integer>]`, e.g., `[1]` --- the `memory` operator, pushes the content of the memory cell into the stack;
- `{<integer>}`, e.g., `{3}` --- the `store` operator, stores the top value from the stack into the memory cell,
the value is removed from the stack.

Below are some examples of expressions:
```
### adds 1 and 2
1.0 2.0 add
### incriments the first input variable
(0) 1 add
1 (0) add
### x / (x + y)
(0) (0) (1) add div
### sqrt(x ** 2 + y ** 2)
(0) (0) mul (1) (1) mul add sqrt
### p(x) log p(x) where p(x) = 1 / sqrt(2 pi) exp(-x * x / 2) (the constant is precomputed)
0.3989422804014327 2 (0) (0) mul div neg exp mul {0} [0] [0] log mul
```

## Machine code

The machine code corresponds to the reverse Polish notation one-to-one:
- each instruction consist of two integer values: the op code and the argument
  (most instructions don't use the argument);
- each operation has its own unique op code.
- in Python instructions are stored as `np.ndarray(shape=(*, 2), dtype=np.int32)`;
  - some instructions, like `const`, interpret the argument as `float` --- one might see wierd values when inspecting
    the binary code because a `float` is read as an integer, for example, `1.0` (`const(1.0)`) is represented
    as `[<op code for const> , 1065353216]`, where the number is binary representation of `1.0` read as `int`
    without casting.

The binary code can be assembled and disassembled as follows:
```python
binary = machine.assembly.assemble('(0) (0) mul (1) (1) mul add sqrt')
print(binary.T)
# [[ 2  2  9  2  2  9  5 15]
#  [ 0  0  0  1  1  0  0  0]]
disassembled = machine.assembly.disassemble(binary)
print(disassembled)
# (0) (0) mul (1) (1) mul add sqrt
```

### Executing the machine

Binary code can be evaluated via the `execute` method of a `symgen.StackMachine`:
```python
from symgen import StackMachine, lib
machine = StackMachine(
    lib.core, lib.std, debug=True, source='test_eval.c'
  )
binary = machine.assembly.assemble('(0) (0) mul (1) (1) mul add sqrt')
sizes = np.array([binary.shape[0]], dtype=np.int32)
inputs = np.arange(10, dtype=np.float32).reshape((1, 5, 2))
outputs = np.ndarray(shape=(1, 5, 1), dtype=np.float32)

machine.execute(binary, sizes, inputs, outputs)
print(outputs)
```

The machine evaluates a set of expressions, each expression in evaluated in a batch of points.
As lengths of expressions vary significantly, the machine expects concatenated binary-code array of size `(N, 2)` with
`sizes` argument of shape `(n expressions, )` signaling the boundaries of expressions.
The inputs array must be of size `(n expressions, batch, input dims)` and of type `np.float32`,
the output array --- `(n expressions, batch, output dims)` and also of type `np.float32`.

The machine copies the remaining stack into the output array once the end of the expression is reached, for example,
the following code:
```
binary = machine.assembly.assemble('(0) (0) mul (1) (1) mul add sqrt (0) (1) add')
```
computes a vector `(y1, y2)` where `y1 = sqrt(x1 ** 2 + x2 ** 2)` and `y2 = x1 + x2`.

The binary code and the sizes array must be of type `np.int32` and input and outputs buffers --- `np.float32`.

### Internals

When an instance of `StackMachine` is created, it generates a C files and compiles it into Python C extension.
The resulting machine is specific to the instruction set and other settings. If one passes `shared` argument,
the resulting shared library will be written into the specified location and, next time, will be loaded instead of
being compiled from scratch.  

The assembly language is meant to be used mostly for introspection: the machine is designed to be used with
generators that output binary code directly.

### Why stack machines?

Stack machines are nicely suited for symbolic expressions. Most of the mathematical expressions can be
effortlessly converted into reverse Polish notation and executed on a stack machine: `(x + y) * z -> x y + z *`.
Naturally, reverse Polish notation is easy and intuitive to work with for generating random expressions.

While it is also possible to convert an expression into the format of RAM / register machines, they come with an additional
hurdle of keeping track of memory / registers: one either has to compile reverse Polish notations into RAM / register machine code
or directly generate such code.

### Why mixed stack-memory machines?

Stack machines have a flaw: they can't easily reuse results of subexpressions.
For example, to compute `p(x) log p(x)` where `p(x)` is some probability density, one has to
duplicate all computations for `p(x)`. Memory operators (`store` and `memory`, `{n}` and `[n]`) allow to
introduce temporary variables into the expression: `<expression for p> {0} [0] [0] log mul`.
An alternative solution, the stack duplication operator, is cumbersome to deal with during expression generation.
Another possibility, copying subexpressions during generation, wastes computational time and needlessly complicates
the generation process.

### Expanding the instruction set

One can introduce a new set of instructions by simply providing template code for the instructions:
```
my_library = dict(
  inc1='const number_t x = POP();\n'
       'PUSH(x + 1);\n'
       'return;',
  inc2='const number_t x = POP();\n'
       'x + 1',
  inc3='POP() + 1'
)
```
All 3 instructions above perform the same operation.

The template code is practically C code with the following features:
- `POP()` and `PUSH(x)` macros are available for stack operations;
- if the last line of the code doesn't contain a return statement, i.e., `return;`, it is assumed to be
the instruction's result and is automatically transformed into an equivalent of `PUSH(<last line>)`;
- operators have signatures `void operator(number_t ** stack, arg_t argument)`, in particular,
  they don't return anything, a `return` statement is only to avoid pushing the last result;
- `${stack}`, `${argument}`, `${input}` and `${memory}` are substituted with proper C expressions for stack,
  operation's arguments, input and memory arrays. Most instructions beyond the core ones usually don't need these.

_Note: there are no safety checks for stack and memory operations. Attempting to `POP()` an empty stack or
`PUSH()` beyond the allocated stack might result in a segmentation fault._

## Generating random expressions

### Grammar

SymGen uses (enhanced) context-free grammar for generating random expressions.
A grammar extends instruction set (terminal symbols) with non-terminal symbols: each non-terminal symbol
is expanded according to the probabilistic transition table until no non-terminal symbols remains.
Transition are picked randomly and are independent of the surrounding expressions (context).
For example, the following grammar generates random expressions with `add` and `mul` operators:
```
expr ->
    expr expr add with probability = 0.2
    expr expr mul with probability = 0.2
    constant with probability = 0.6
constant ->
    0 with probability = 0.2
    1 with probability = 0.2
    2 with probability = 0.2
    3.1415 with probability = 0.2
    2.7182 with probability = 0.2
```

In SymGen this grammar can be defined as follows:
```python
import math
import symgen
from symgen.generator import Grammar, symbol, op

libraries = (symgen.lib.core, symgen.lib.std)

expr = symbol('expr')()
constant = symbol('constant')()

grammar = Grammar(
  rules={
    expr: {
      expr + expr + op('add'): 0.2,
      expr + expr + op('mul'): 0.2,
      constant: 0.6,
    },
    constant: {
      op('const')(0.0): 0.2,
      op('const')(1.0): 0.2,
      op('const')(2.0): 0.2,
      op('const')(math.pi): 0.2,
      op('const')(math.e): 0.2,
    }
  }
)
```

`symbol(<symbol name>)(<arguments>)` creates a non-terminal symbol with the corresponding name and arguments (see below).
`rules` is a dictionary that maps `Condition` into a transition table, a dictionary mapping `Expansion`s into probabilities
(probability values are automatically normalized to 1).

If the transition table contains only one expansion, one can use the simplified syntax:
```python
rules={
  expr: subexpr + subexpr + op('add')
}
```
Also `expr: None` is an alternative to `expr: {}`.

Note, `const` is the name of the core operator.

Behind the scenes, SymGen turns each non-terminal into a C function that recursively calls expansion function of other symbols:
```C
static int symgen_expand_expr(...) {
  const double u = random();
  
  if (u < 0.2) {
    symgen_expand_expr(...);
    symgen_expand_expr(...);
    <write add>
  } else if (u < 0.4) {
    symgen_expand_expr(...);
    symgen_expand_expr(...);
    <write mul>
  }
  ...
}
```

### Runaway grammars

It is quite easy to produce a "runaway" grammar: grammar that has a significant chance of exceeding any reasonable limits.
For example, the following grammar:
```
expr -> expr expr add, p = 0.9;
expr -> constant, p = 0.1;
```
has a non-zero chance of "running away" during generation.
To prevent this, SymGen tracks the number of expressions written by the generator and raises an exception if
any expansion goes over this limit. It is also possible to mistakenly produce an infinitely expanding grammar
that does not generate any operations. For example, forgetting `add` operator:
```
expr -> expr expr, p = 0.9;
expr -> constant, p = 0.1;
```
produces an effectively infinite recursion. To avoid the second case, SymGen also tracks depths of the recursion,
and raise an error when the limit is reach.
Both mechanism serve as a safeguard against mistakes, and are not designed for rejection sampling.

It is highly advisable to write a priori finite grammars. The following section introduces the extension of the free grammar
that helps us to constrain the generation process.

### Arguments and guards

Non-terminal symbols can accept an arbitrary number of parameters. To use parameters, they must be declared
during the creating of a `Symbol`:
```python
from symgen import Grammar, symbol

expr = symbol('expr')('i', 'j', 'k')
```
These parameters are directly translated into the C function:
```C
static int symgen_expand_expr(..., int i, int j, int k);
```
By default, all parameters are of type `int`, but it is possible to specify different types:
```
expr = symbol('expr')('float i', 'char j', 'const unsigned long * k')
```

The parameters can be modified during the expansion:
```python
expr = symbol('i', 'j', 'k')
rules={
  expr: {
    expr(j=0, i='i - 1') + expr('i - 1') + op('add'): 1,
    expr('i - 1') + expr('i - 1') + op('mul'): 1,
    op('const')(1.0): 1,
  },
  ...
}
```
The arguments in the expansion can be any C expression: `i + j`, `i << 2` etc.
SymGen tries to match arguments following the rules:
- it first matches non-keyword arguments to the signature: `expr(1.0, k=2.0)` matches `i=1.0`;
- then, it adds keyword arguments: `expr(1.0, k=2.0)` now matches `i=1.0, k=2.0`;
- then, it fills all unspecified arguments with variables of the same name from the scope:
  `expr(1.0, k=2.0)` matches `i=1.0, j=j, k=2.0`.

*The last rule implicitly pass arguments with the same name even if symbols are different*, for example,
in the following grammar: 
```
expr1 = symbol('expr1')('i')
expr2 = symbol('expr2')('i')
rules={
  expr1: {expr2: 1.0},
  expr2: ...
}
```
`expr1` implicitly passes its argument `i` to `expr2`.

The parameters can also be used in conditions, for the transition:
```python
transitions={
  expr.when('i > 0', 'j > 0'): ...,
  expr.when('(i == 0) || (j == 0)'): ...,
  expr: ...,
}
```
The `when` method of a symbol produces a `Conditon`, just a symbol is interpreted as an empty condition.

Conditions can be any C expression. Multiple conditions are combined with `&&` (and). Conditions don't have to be
mutually exclusive, they are matched in the same order as declared: in the example above the last transition is expanded
only if the first two fail to match the state.

In the C code guards are turned into `if (...) {} else if (...) {}` chain:
```C
static int symgen_expand_expr(..., int i, int j) {
  if ((i > 0) && (j > 0)) {
    ...
  } else if ((i == 0) || (j == 0)) {
    ...
  } else if (1) {
    ...
  }
}
```

### Arguments to terminal symbols

Terminal symbols in the expansion rules can also accept at most one argument.
```python
constant: {
  op('const')(1.0): 1,
  op('input')('RANDOM_INPUT()'): 1,
},
```

Here, non-terminal `constant` can be expanded into `1.0` (as constant value) or `(<random input variable>)`.
`RANDOM_INPUT` is a predefined macro in the C code.

### Special arguments

There are several special arguments, function and macros available in the C code, that can be used in symbol expansion:
- `int depth` --- tracks the depth of the recursion, *normally should not be modified*, 
  automatically propagated as `depth - 1`;
- `BitSet domain` --- a utility variable to track allowed input variables (also called domain),
  automatically propagated without changes;

All special arguments are accessible via keyword arguments in expansions and by their name in conditions:
```python
rules={
  expr: {
    subexpr(i=4, domain='RANDOM_SUBSET()') + subexpr(i=5, domain='RANDOM_SUBSET()') + op('mul'): 1,
  },
  subexpr.when('i > 0', 'domain.size > 0') : {
    subexpr(i='i - 1') + op('input')('RANDOM_INPUT()') + op('add'): 1,
  }
  subexpr('domain.size == 0'): {
    op('const')(0.0): 1
  }
  subexpr : {
    op('input')('RANDOM_INPUT()'): 1,
  }
}
```
The example above generates product of two sums, where the variables in each sum are drawn from a random subset.


## A performance test

For example, evaluating an equivalent of `np.sum(x[:n] * x[n:])` on 64 points with `n=32` 16000 times yields:
```
SymGen: 0.235 seconds
eval: 5.977 seconds
eval + numpy: 0.565 seconds
NumPy: 0.049 seconds
Binary (estimated): 0.025 seconds
```
where:
- `eval` executes pre-compiled Python expression `x[0] * x[32] + x[1] * x[33] + ...` for each point;
- `eval + numpy` vectorizes operations with numpy: `x[:, 0] * x[:, 32] + x[:, 1] * x[:, 33] + ...`;
- `numpy`: `np.sum(x[:, :, :n] * x[:, :, n:], axis=2)`;
- `Binary` is estimated for a 4 GFlops core (with fully inline code, e.g., fully unrolled loops).

Note, that numpy gains a large speed-up due to repeating operations. Performance on arbitrary expressions is
shown by the vectorized `eval`.



